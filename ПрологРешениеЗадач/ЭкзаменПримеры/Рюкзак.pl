%Построить предикат, позволяющий получить подмножество исходного 
%множества. На его основе решить задачу компоновки рюкзака минимального веса. Дан рюкзак 
%с заданным объемом V. Дан набор объектов [[3,4], [5,6], [7,8], [4,5]], где первое число объем 
%объекта, второе число вес объекта. Сначала решить задачу нахождения подмножества 
%объектов, сумма объемов которых равна объему рюкзака. Далее найти такое подмножество 
%объектов, сумма объектов которых равна объему рюкзака, а сумма весов объекта минимальна 
%возможна.


% subset(+List:List, -Subset:List)
% Предикаты для генерации подмножеств. Истинно, если Subset является подмножеством List.
subset([], []).  %Пустое множество является подмножеством любого множества.
%Подмножество включает первый элемент списка
subset([X|Xs], [X|Ys]) :-
    subset(Xs, Ys). %Рекурсивно включаем первый элемент X и строим подмножество из оставшихся элементов Xs.
%Подмножество не включает первый элемент списка
subset([_|Xs], Ys) :-
    subset(Xs, Ys). %Рекурсивно строим подмножество из оставшихся элементов Xs, игнорируя первый элемент.

%sum_volumes(+Objs:List, -Sum:integer)
% Предикаты для суммирования объемов всех объектов в списке. Истинно,
% если Sum является суммой объемов всех объектов в списке Objs. Сумма
% объемов пустого списка равна 0
sum_volumes([], 0). %Базовый случай: сумма объемов пустого списка равна 0.
%Суммирование объемов объектов
sum_volumes([[V,_]|Objs], Sum) :-
    sum_volumes(Objs, RestSum), %Рекурсивно вычисляем сумму объемов оставшихся объектов.
    Sum is V + RestSum.  %Суммируем объем текущего объекта и оставшуюся сумму.

%sum_weights(+Objs:List, -Sum:integer)
% Предикат вычисляет сумму весов всех объектов в списке.Истинно, если Sum
% является суммой весов всех объектов в списке Objs. Сумма весов пустого списка равна
sum_weights([], 0). %Базовый случай: сумма весов пустого списка равна 0.
%Суммирование весов объектов
sum_weights([[_V,W]|Objs], Sum) :-
    sum_weights(Objs, RestSum), %Рекурсивно вычисляем сумму весов оставшихся объектов.
    Sum is W + RestSum. %Суммируем вес текущего объекта и оставшуюся сумму.

% subset_with_volume(+Objs:List, +V:integer, -Subset:List)
% Подмножество с заданным объемом. Истинно, если Subset является
% подмножеством объектов Objs с суммарным объемом V.
subset_with_volume(Objs, V, Subset) :-
    subset(Objs, Subset), %Генерируем подмножество объектов.
    sum_volumes(Subset, V). %Проверяем, что сумма объемов этого подмножества равна V.

%min_weight_subset(+Objs:List, +V:integer, -MinWeightSubset:List)
%Нахождение подмножества с минимальным весом. Истинно, если MinWeightSubset является подмножеством объектов Objs с суммарным объемом V и минимальным весом.
min_weight_subset(Objs, V, MinWeightSubset) :-
    findall(Subset, subset_with_volume(Objs, V, Subset), Subsets), %Находим все подмножества с объемом V.
    maplist(sum_weights, Subsets, Weights),  %Вычисляем вес каждого подмножества.
    min_list(Weights, MinWeight), %Находим минимальный вес.
    nth0(Index, Weights, MinWeight), %Находим индекс подмножества с минимальным весом.
    nth0(Index, Subsets, MinWeightSubset). %Извлекаем подмножество с минимальным весом по индексу.

% Основной предикат
main :-
    Objects = [[3, 4], [5, 6], [7, 8], [4, 5]], %Список объектов
    Volume = 10, %Заданный объем
    min_weight_subset(Objects, Volume, MinWeightSubset),  %Находит подмножество с заданным объемом и минимальным весом.
    write('Минимальное подмножество объектов с объемом '), write(Volume), write(': '), writeln(MinWeightSubset).
