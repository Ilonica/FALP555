%Написать предикат, который по заданному графу возвращает произвольное 
%максимальное паросочетание. Модифицировать предикат так, чтобы он выявлял наибольшее 
%паросочетание.

% edge(+X:integer, +Y:integer)
% Заданный граф. edge(X, Y) ребро между вершинами
% X и Y.
edge(1, 2).
edge(2, 3).
edge(3, 4).
edge(4, 5).
edge(5, 6).
edge(6, 1).
edge(2, 4).
edge(3, 5).

% matched(+X:integer, +Y:integer)
% Предикат, который будет хранить текущее паросочетание.
:- dynamic matched/2.

% Инициализация (очищение) текущего паросочетания.
initialize_matching :- retractall(matched(_, _)).

% Найти произвольное максимальное паросочетание.
find_maximal_matching :-
    initialize_matching, %Очищает текущее паросочетание.
    findall((X, Y), edge(X, Y), Edges), %Находит все ребра в графе.
    match_edges(Edges). %Пытается добавить каждое ребро в паросочетание.

%match_edges(+Edges:list)
%Попытаться добавить ребро в паросочетание.
match_edges([]). %Базовый случай: пустой список ребер.
match_edges([(X, Y) | Rest]) :-
    (   \+ matched(X, _), \+ matched(Y, _) -> %Если ни X, ни Y не находятся в текущем паросочетании
        assertz(matched(X, Y)), %Добавляет ребро (X, Y) в паросочетание.
        assertz(matched(Y, X)) %Добавляет ребро (Y, X) в паросочетание (обратное направление).
    ;   true  %Если одно из них уже в паросочетании, пропустить это ребро.
    ),
    match_edges(Rest).  %Рекурсивно обрабатывает оставшиеся ребра.

%Вывести текущее паросочетание.
print_matching :-
    findall((X, Y), matched(X, Y), Matching), %Находит все ребра в текущем паросочетании.
    writeln(Matching).

% Запуск поиска паросочетания и вывод результата.
main :-
    find_maximal_matching,
    print_matching.
